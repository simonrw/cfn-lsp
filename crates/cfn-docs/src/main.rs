use std::collections::{HashMap, HashSet};
use std::fmt::Write;

use cfn_lsp_schema::Handler;
use clap::Parser;
use color_eyre::eyre::{self, Context};
use termimad::crossterm::style::Color;
use termimad::{Alignment, MadSkin, StyledChar, rgb};

#[derive(Parser)]
struct Args {
    resource_type: String,
}

fn setup_theme(skin: &mut MadSkin) {
    skin.set_headers_fg(rgb(255, 187, 0));
    skin.bold.set_fg(Color::Yellow);
    skin.italic.set_fgbg(Color::Magenta, rgb(30, 30, 40));
    skin.bullet = StyledChar::from_fg_char(Color::Yellow, 'âŸ¡');
    skin.quote_mark.set_fg(Color::Yellow);
    skin.table.align = Alignment::Left;
}

fn main() -> eyre::Result<()> {
    color_eyre::install().unwrap();

    let args = Args::parse();
    let resource_info = cfn_lsp_schema::extract_resource_from_bundle(&args.resource_type)
        .wrap_err("Could not read resource schema")?;

    let markdown = render_to_markdown(&resource_info).context("rendering to markdown")?;

    let mut skin = MadSkin::default();
    setup_theme(&mut skin);
    skin.print_text(&markdown);

    Ok(())
}

static TABLE_HEADER: &str = r#"
|:-:|-
|**Method**|**Name**|
|:-:|-
"#;

fn render_table<W>(
    permissions: &HashMap<Handler, Option<Vec<String>>>,
    writer: &mut W,
) -> Result<(), std::fmt::Error>
where
    W: Write,
{
    write!(writer, "{TABLE_HEADER}")?;
    let handlers = [
        Handler::Create,
        Handler::Read,
        Handler::Update,
        Handler::Delete,
    ];
    for handler in handlers {
        let Some(permissions) = permissions.get(&handler).cloned().unwrap_or(None) else {
            continue;
        };
        let method = handler.to_string();

        for (i, permission) in permissions.iter().enumerate() {
            if i == 0 {
                writeln!(writer, "|{method}|{permission}|")?;
            } else {
                writeln!(writer, "||{permission}|")?;
            }
        }
        writeln!(writer, "|:-:|-")?;
    }
    Ok(())
}

fn render_to_markdown(
    resource_info: &cfn_lsp_schema::ResourceInfo,
) -> Result<String, std::fmt::Error> {
    let mut s = String::new();

    writeln!(&mut s, "# {}", resource_info.type_name)?;
    writeln!(&mut s)?;

    writeln!(&mut s, "## Description")?;
    let description = resource_info.description.clone().unwrap_or_default();
    writeln!(&mut s, "{description}")?;
    writeln!(&mut s)?;

    writeln!(&mut s, "## Physical resource id")?;
    writeln!(&mut s, "{}", resource_info.primary_identifier)?;
    writeln!(&mut s)?;

    writeln!(&mut s, "## Properties that require replacement")?;
    for prop in &resource_info.create_only_properties {
        writeln!(&mut s, "* {prop}")?;
    }
    writeln!(&mut s)?;

    writeln!(&mut s, "## Properties generated by CloudFormation")?;
    for prop in &resource_info.read_only_properties {
        writeln!(&mut s, "* {prop}")?;
    }
    writeln!(&mut s)?;

    writeln!(&mut s, "## Properties not available through intrinsics")?;
    let mut unique_properties = resource_info
        .write_only_properties
        .iter()
        .map(|p| p.split('/').next().unwrap_or(p))
        .collect::<HashSet<_>>()
        .into_iter()
        .collect::<Vec<_>>();
    unique_properties.sort();
    for prop in unique_properties {
        let prop = prop.split('/').next().unwrap_or(prop);
        writeln!(&mut s, "* {prop}")?;
    }
    writeln!(&mut s)?;

    writeln!(&mut s, "## Handlers")?;
    render_table(&resource_info.handler_permissions, &mut s)?;

    Ok(s)
}
